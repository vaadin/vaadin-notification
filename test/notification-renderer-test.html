<!doctype html>

<head>
  <meta charset="UTF-8">
  <title>vaadin-notification tests</title>
  <script src="../../../wct-browser-legacy/browser.js"></script>
  <script src="../../../@webcomponents/webcomponentsjs/webcomponents-bundle.js"></script>
  <script type="module" src="../../../@polymer/test-fixture/test-fixture.js"></script>
  <script type="module" src="../vaadin-notification.js"></script>
</head>

<body>
  <test-fixture id="default">
    <template>
      <vaadin-notification></vaadin-notification>
    </template>
  </test-fixture>

  <test-fixture id="with-template">
    <template>
      <vaadin-notification>
        <template>
          notification-content
        </template>
      </vaadin-notification>
    </template>
  </test-fixture>

  <script type="module">
import '@polymer/test-fixture/test-fixture.js';
import '../vaadin-notification.js';
describe('vaadin-notification', function() {
  let rendererContent;

  beforeEach(function() {
    rendererContent = document.createElement('p');
    rendererContent.innerText = 'renderer-content';
  });

  describe('without template', () => {
    let notification;

    beforeEach(() => {
      notification = fixture('default');

      // Force sync card attaching and removal instead of waiting for the animation
      sinon.stub(notification, '_animatedAppendNotificationCard', () => notification._appendNotificationCard());
      sinon.stub(notification, '_animatedRemoveNotificationCard', () => notification._removeNotificationCard());

      notification.open();
    });

    afterEach(() => {
      // Close to stop all pending timers.
      notification.close();
      // delete singleton reference, so as it's created in next test
      delete notification.constructor._container;
    });

    it('should use renderer when it is defined', () => {
      notification.renderer = root => root.appendChild(rendererContent);
      notification.opened = true;
      expect(notification._card.textContent.trim()).to.equal('renderer-content');
    });

    it('renderer should receive notification when defined', () => {
      notification.renderer = (root, notification) => {
        expect(notification).to.eql(notification);
      };
    });

    it('should remove template when added after renderer', () => {
      notification.renderer = () => {};
      const template = document.createElement('template');
      expect(() => {
        notification.appendChild(template);
        notification._observer.flush();
      }).to.throw(Error);
      expect(notification._notificationTemplate).to.be.not.ok;
    });

    it('should be possible to manually invoke renderer', () => {
      notification.renderer = sinon.spy();
      notification.opened = true;
      expect(notification.renderer).to.be.calledOnce;
      notification.render();
      expect(notification.renderer).to.be.calledTwice;
    });

    it('should provide root from the previous renderer call', () => {
      notification.renderer = root => {
        const generatedContent = document.createTextNode('rendered');
        root.appendChild(generatedContent);
      };
      notification.opened = true;
      notification.opened = false;
      notification.opened = true;
      expect(notification._card.textContent.trim()).to.equal('renderedrendered');
    });

    it('should clear the root when renderer changed', () => {
      for (let i = 0; i < 2; i++) {
        notification.renderer = root => {
          const generatedContent = document.createTextNode('rendered-' + i);
          root.appendChild(generatedContent);
        };
        notification.opened = true;
        expect(notification._card.textContent.trim()).to.equal('rendered-' + i);
      }
    });

    it('should open notification when renderer is defined after notification opened', done => {
      notification.opened = true;
      notification.renderer = root => root.appendChild(rendererContent);

      // Timeout needed for Firefox
      setTimeout(() => {
        const clientRect = notification._card.getBoundingClientRect();
        expect(clientRect.x).to.not.equal(0);
        expect(clientRect.y).to.not.equal(0);
        expect(clientRect.width).to.not.equal(0);
        expect(clientRect.height).to.not.equal(0);
        expect(clientRect.top).to.not.equal(0);
        done();
      });
    });
  });

  describe('with template', () => {
    let notification;

    beforeEach(() => {
      notification = fixture('with-template');

      // Force sync card attaching and removal instead of waiting for the animation
      sinon.stub(notification, '_animatedAppendNotificationCard', () => notification._appendNotificationCard());
      sinon.stub(notification, '_animatedRemoveNotificationCard', () => notification._removeNotificationCard());

      notification.open();
    });

    afterEach(() => {
      // Close to stop all pending timers.
      notification.close();
      // delete singleton reference, so as it's created in next test
      delete notification.constructor._container;
    });

    it('should fallback to render content with Templatizer when renderer is not defined', () => {
      expect(notification._card.textContent.trim()).to.equal('notification-content');
    });

    it('should throw an error when setting a renderer if there is already a template', () => {
      notification._observer.flush();
      expect(() => notification.renderer = () => {}).to.throw(Error);
    });

    it('should remove renderer when added after template', () => {
      expect(() => notification.renderer = () => {}).to.throw(Error);
      expect(notification.renderer).to.be.not.ok;
    });
  });
});
</script>
</body>
